# 隐式转化

以下是一些常见的情况：

1. **构造函数调用**：当你调用一个函数，并且参数类型不匹配时，编译器会尝试进行隐式类型转换来匹配参数。这可能导致构造函数被隐式调用，从而进行类型转换。

   ```c++
   MyClass obj = 42; // 隐式调用 MyClass(int) 构造函数
   ```

2. **函数参数传递**：当你调用一个函数并传递参数时，如果参数类型不匹配，编译器也会尝试进行隐式类型转换来匹配函数的参数类型。
   
   ```c++
   void foo(MyClass obj);

   foo(42); // 隐式调用 MyClass(int) 构造函数，然后传递给 foo 函数
   ```

3. **返回值**：当一个函数返回一个对象时，如果返回类型与函数期望的类型不匹配，编译器也会尝试进行隐式类型转换。

   ```c++
   MyClass getMyClass() {
       return 42; // 隐式调用 MyClass(int) 构造函数，然后返回
   }
   ```

在这些情况下，如果构造函数声明为 `explicit`，那么将禁止这种隐式类型转换，必须显式地进行类型转换。