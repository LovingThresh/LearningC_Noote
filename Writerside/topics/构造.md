# 构造

## 构造函数与析构函数
在 C++ 中，类（或结构体，它们之间的主要区别是默认访问权限）可以有几种不同的特殊成员函数，这些函数用于创建、复制、移动和销毁类的实例。这张图片展示了这些特殊成员函数的定义。下面是它们的总结：

1. **默认构造函数** (`C();`)
	- 用于构建一个新的对象实例，没有提供任何初始化值时调用。

2. **拷贝构造函数** (`C(const C& c);`)
	- 当创建一个新的对象实例，并以同类型的另一个对象作为初始化值时调用。
	- 进行值传递、返回局部对象、以值初始化数组等情况时也会调用。

3. **移动构造函数** (`C(C&& c);`) *(C++11 引入)*
	- 当创建一个新的对象实例，并以同类型的临时对象（右值）作为初始化值时调用。
	- 用于实现"移动语义"，可以提高临时对象操作的效率。

4. **拷贝赋值运算符** (`C& operator=(const C& c);`)
	- 当通过 `=` 将一个对象赋值给另一个已经存在的对象时调用。
	- 负责将一个对象的内容拷贝到另一个对象中。

5. **移动赋值运算符** (`C& operator=(C&& c);`) *(C++11 引入)*
	- 当通过 `=` 将一个临时对象（右值）赋值给另一个已经存在的对象时调用。
	- 负责实现"移动语义"，它通常会窃取资源，而不是创建它们的副本。

6. **析构函数** (`~C();`)
	- 当对象的生命周期结束时调用。
	- 负责执行对象的清理工作，如释放资源等。

![Constructor.png](Constructor.png)
### 注意事项
- **默认成员函数**: 如果你没有声明上述任何一个函数，编译器会为你隐式声明一个默认的版本（除了移动构造函数和移动赋值运算符，只有在没有声明任何拷贝操作、移动操作或析构函数时才会被隐式声明）。
- **删除的函数**: 在 C++11 及以后，你可以显式地删除这些特殊成员函数，如 `C(const C& c) = delete;`，表示对象不能被拷贝构造。
- **默认的函数**: 你也可以显式地要求编译器生成默认的特殊成员函数，如 `C(const C& c) = default;`。
- **隐式定义**: 如果你声明了其他构造函数，编译器不会自动生成默认构造函数。在这种情况下，如果你需要一个默认构造函数，必须显式声明它。

在设计类时，合理使用这些特殊成员函数对于管理对象资源和保证程序正确性至关重要。选择哪些需要自定义，哪些使用默认实现，或者完全删除，这取决于类的特定需求。

## 浅拷贝
浅拷贝（Shallow Copy）在 C++ 中是一个基本概念，涉及到对象的复制方式。当执行浅拷贝时，对象的数据成员被逐个复制到新对象中。对于非指针或非引用类型的数据成员，这通常不会造成问题，因为每个成员都有其自己的独立副本。

问题出现在对象含有指针成员时。浅拷贝会直接复制指针的值，意味着新对象的指针成员和原对象将指向同一块内存地址。这种行为可能导致以下问题：

1. **重复释放内存**：当两个对象被析构时，指向同一内存的指针会被尝试释放两次，这会导致未定义行为，通常是程序崩溃。

2. **非期望的数据共享**：因为两个对象共享同一内存，对一个对象的修改可能会影响另一个对象，这往往不是程序员所期望的。

3. **悬空指针**：如果一个对象被销毁，它可能会释放共享的内存资源，而另一个对象仍然指向这块已经被释放的内存。

### 例子

假设我们有一个简单的类 `A`，它包含一个指向 `int` 的指针成员：

```c++
class A {
public:
    int* ptr;
    
    A(int val) {
        ptr = new int(val);
    }
    
    ~A() {
        delete ptr;
    }
};

int main() {
    A obj1(10);
    A obj2 = obj1; // 浅拷贝发生在这里
    // obj1 和 obj2 的 ptr 成员现在指向同一块内存

    return 0; // 当 main 结束时，obj1 和 obj2 都会被析构，ptr 会被删除两次
}
```

在这个例子中，`obj2` 是通过拷贝构造函数以 `obj1` 为原型创建的。因为 `A` 的拷贝构造函数是隐式的（编译器生成的），所以执行的是浅拷贝，这导致了 `obj1` 和 `obj2` 的 `ptr` 成员指向同一块内存。当 `main` 函数结束时，`obj1` 和 `obj2` 都会尝试释放 `ptr` 指向的内存，导致上述的问题。

### 解决方法

为了避免浅拷贝导致的问题，通常需要实现自定义的拷贝构造函数和拷贝赋值运算符，进行深拷贝（Deep Copy）。

## 深拷贝
深拷贝并不是复制指针本身的值（即内存地址），而是复制指针所指向的数据到一块新的内存区域，并让新对象的指针指向这块新的内存。这样，即使两个对象的指针类型成员指向了不同的地址，这些地址中的数据是相同的。这避免了两个对象共享同一内存区域带来的问题。

正确的说法应该是：“深拷贝会创建指针指向的数据的一个新的副本，然后将新对象的指针成员指向这个副本，确保每个对象都有指向自己独立数据副本的指针。”

以下是深拷贝的示例：

```c++
class A {
public:
    int* ptr;
    
    // 构造函数
    A(int val) {
        ptr = new int(val);
    }
    
    // 拷贝构造函数
    A(const A &other) {
        ptr = new int(*other.ptr); // 深拷贝：复制指针指向的数据
    }
    
    // 析构函数
    ~A() {
        delete ptr;
    }
};
```

在这个示例中，拷贝构造函数为 `ptr` 指向的数据创建了一个新的副本。这意味着 `A` 类的两个对象 —— 即原始对象和拷贝构造的新对象 —— 有不同的 `ptr` 成员，这些成员指向不同的内存地址，每个地址中存储了相同的数据值。

## 拷贝与移动构造
假设我们有两个 `std::vector<int>`，分别是 `v1` 和 `v2`，其中 `v1` 包含10个元素，`v2` 包含100个元素。现在我们来看看发生拷贝和移动操作时的具体情况。

### 拷贝操作
当我们执行拷贝操作时，如：

```c++
std::vector<int> v1(10, 1); // 10个元素，每个元素的值都是1
std::vector<int> v2(100, 2); // 100个元素，每个元素的值都是2

// 执行拷贝操作
std::vector<int> v3 = v1; // 拷贝构造函数
std::vector<int> v4;
v4 = v2; // 拷贝赋值运算符
```

在上面的代码中，`v3` 是通过拷贝构造函数从 `v1` 创建的，`v4` 是通过拷贝赋值运算符从 `v2` 创建的。在这两种情况下，新的向量（`v3` 和 `v4`）会分别分配新的内存，并将 `v1` 和 `v2` 中的所有元素复制到这些新分配的内存中。因此，每个向量都拥有自己的内存副本，互不影响。

### 移动操作
当我们执行移动操作时，如：

```c++
std::vector<int> v1(10, 1); // 10个元素，每个元素的值都是1
std::vector<int> v2(100, 2); // 100个元素，每个元素的值都是2

// 执行移动操作
std::vector<int> v5 = std::move(v1); // 移动构造函数
std::vector<int> v6;
v6 = std::move(v2); // 移动赋值运算符
```

在上面的代码中，我们用 `std::move` 将 `v1` 和 `v2` 转换为右值引用，这导致 `v5` 通过移动构造函数创建，而 `v6` 通过移动赋值运算符被赋值。移动操作实质上是将 `v1` 和 `v2` 中的内部状态（包括指向动态分配内存的指针）直接传递给 `v5` 和 `v6`。在移动操作之后，`v1` 和 `v2` 不再拥有那些内存，其状态变为“移动后状态”，通常这意味着它们变为空的或者至少是处于不包含任何元素的状态。

由于不需要数据复制，移动操作非常快速，特别是对于像向量这样的包含大量数据的容器来说，这是一个很大的优势。`v1` 和 `v2` 移动之后可能会被销毁，但由于它们的资源已经被转移，所以没有什么要被清理的，它们会安全地被销毁而不会造成资源泄漏。

### 总结
- **拷贝**：就像你拍了一张你家宠物的照片并给了你的朋友一张完全一样的照片。你和你的朋友现在各自拥有一张照片，彼此完全独立。
- **移动**：就像你把你的宠物送给了你的朋友，现在宠物是你朋友的了，而你没有了。如果你家宠物是一只大象，移动就避免了把大象复制一遍的需要，节省了时间和资源。

在代码层面，移动操作通过 "窃取" 资源而非复制它们来提高效率，这在处理大型数据结构

（如大型向量）时特别有用。而拷贝则是传统的按值复制资源的方式。在设计和实现类时，理解和正确使用这两种操作对于编写高效和正确的 C++ 程序至关重要。

## 拷贝与构造
在 C++ 中，`std::vector` 的拷贝和移动操作都会正确处理容量和大小的问题，因为这些操作都是由 `std::vector` 类内部实现的。

### 拷贝场景
当你执行拷贝操作，如 `v2 = v1;`，这里假设 `v1` 的大小是 10，`v2` 的大小是 100：

1. **大小（Size）**：`v2` 的大小会被改变为 10，与 `v1` 的大小相同。
2. **容量（Capacity）**：`v2` 的容量至少会是 10。如果 `v2` 原先的容量足以容纳 10 个元素，它可能不会变化。如果 `v2` 原先的容量小于 10 或 `std::vector` 决定重新分配内存以提高内存使用效率，`v2` 的容量可能会变大。

相反地，当你执行拷贝操作，如 `v1 = v2;`：

1. **大小**：`v1` 的大小会被改变为 100。
2. **容量**：`v1` 的容量将被增加到至少能够容纳 100 个元素。如果 `v1` 原先的容量小于 100，内存会被重新分配。

在这两种情况下，拷贝操作都会确保目标 `vector` 的大小和容量与源 `vector` 一致，或者符合拷贝后的容量需求。

### 移动场景
当你执行移动操作，如 `v2 = std::move(v1);`：

1. **大小**：`v2` 的大小现在是 10。
2. **容量**：`v2` 的容量变为 `v1` 移动前的容量。
3. **v1 状态**：`v1` 被置为一个有效但未定义的状态。这通常意味着 `v1` 的大小是 0，容量可能也是 0（但这取决于 `vector` 的实现）。

如果你执行 `v1 = std::move(v2);`：

1. **大小**：`v1` 的大小现在是 100。
2. **容量**：`v1` 的容量变为 `v2` 移动前的容量。
3. **v2 状态**：`v2` 被置为一个有效但未定义的状态，大小和容量可能都是 0。

### 总结
在进行拷贝或移动操作时，不必担心 `std::vector` 的容量会出错。如果发生拷贝，目标向量的容量将自动调整以确保可以存储所有元素。如果发生移动，源向量的整个状态（包括所有元素和与这些元素相关的容量）将转移到目标向量，源向量则变为一个不含元素的状态。C++ 标准库保证了这些操作的正确性和安全性，无论向量的初始大小和容量如何。在进行移动操作后，源对象通常应该被认为是空的，不应再使用它们来访问任何元素。