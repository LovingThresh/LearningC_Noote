# 独享指针传参

在C++的智能指针中，`std::unique_ptr` 是一种不能被拷贝的智能指针，这是因为它采用了独占所有权的语义。`std::unique_ptr` 确保同一时间内只有一个智能指针实例可以拥有指向某个对象的指针。这个设计目的是为了防止资源的多重删除，保证资源管理的清晰和唯一性。

## 独享指针属性

### 为什么不能Copy`std::unique_ptr`

`std::unique_ptr` 的拷贝构造函数和拷贝赋值运算符都被显式地删除了，这是为了保证对象的唯一所有权。如果允许拷贝，就会存在两个智能指针指向同一个对象，当这两个智能指针销毁时会尝试释放同一个资源两次，从而导致运行时错误。

### 如何传递`std::unique_ptr`

由于 `std::unique_ptr` 不能被拷贝，如果你需要将其传递到一个函数中，通常有以下几种方式：

1. **通过引用传递**：
   可以通过引用传递 `std::unique_ptr`，这样可以避免所有权的转移，同时函数可以使用或修改智能指针指向的对象。

   **示例代码**：
   ```c++
   void process(std::unique_ptr<int>& ptr) {
       *ptr += 10;  // 修改指针指向的值
   }
   ```

2. **通过移动语义传递**：
   如果你想在函数内部完全接管这个指针的所有权，可以使用 `std::move()` 来传递 `std::unique_ptr`。这样，原始的智能指针将不再拥有对象，所有权转移给了函数的参数。

   **示例代码**：
   ```c++
   void process(std::unique_ptr<int> ptr) {
       *ptr += 10;  // 修改指针指向的值
   }

   int main() {
       std::unique_ptr<int> myPtr = std::make_unique<int>(100);
       process(std::move(myPtr));  // myPtr 现在为空，所有权已经转移
       return 0;
   }
   ```

3. **使用原始指针**：
   另一种方法是从 `std::unique_ptr` 中提取原始指针，并将其传递给需要的函数。这种方法不涉及所有权的转移，只是单纯地传递访问权限。

   **示例代码**：
   ```c++
   void process(int* ptr) {
       if (ptr) {
           *ptr += 10;  // 修改指针指向的值
       }
   }

   int main() {
       std::unique_ptr<int> myPtr = std::make_unique<int>(100);
       process(myPtr.get());  // 传递原始指针
       return 0;
   }
   ```

### 总结

当你需要在函数中使用或者修改 `std::unique_ptr` 指向的对象但不需要所有权时，通过引用或原始指针传递是合适的选择。如果你需要在函数中接管所有权，那么应该使用移动语义。选择正确的传递方式可以确保资源管理的正确性，避免资源泄露和无效的指针操作。

## 说明

在上述三种传递 `std::unique_ptr` 的方式中，只有通过**移动语义传递**会导致原有的 `std::unique_ptr` 对象失去对其原始资源的所有权，这可能导致被调用的函数中的 `std::unique_ptr` 被销毁时释放资源。这是因为移动操作会将资源的所有权从一个 `std::unique_ptr` 转移给另一个 `std::unique_ptr`，使得原来的指针为空。

### 通过移动语义传递

当你通过移动语义传递 `std::unique_ptr` 时（使用 `std::move()`），原始的智能指针会失去对其管理的对象的所有权，并将这个所有权转交给函数参数中的 `std::unique_ptr`。因此，一旦这个新的 `std::unique_ptr` 离开其作用域（比如函数执行完毕），它会自动释放它所拥有的资源，除非这个所有权再次被转移。

**示例**：

```c++
void process(std::unique_ptr<int> ptr) {
    *ptr += 10;  // 修改指针指向的值
    // ptr 离开作用域并释放所拥有的资源
}

int main() {
    std::unique_ptr<int> myPtr = std::make_unique<int>(100);
    process(std::move(myPtr));  // myPtr 现在为空，所有权已经转移
    // 这里 myPtr 为空，没有资源可以被释放
    return 0;
}
```
在这个示例中，当 `process` 函数完成后，传入的 `std::unique_ptr` （即 `ptr`）会被销毁，因此它所管理的内存也会被释放。

### 通过引用传递和使用原始指针

- **通过引用传递**：这种方式不会导致 `std::unique_ptr` 被释放，因为所有权并未被转移，只是允许函数通过引用操作指针。
- **使用原始指针**：同样，这种方式也不会导致 `std::unique_ptr` 被释放，因为原始指针的使用并不涉及所有权的概念，只是提供了对对象的访问。

这两种方式都不会在函数调用结束时导致资源的释放，因为 `std::unique_ptr` 的所有权并未离开原来的拥有者。因此，唯一会直接导致 `std::unique_ptr` 资源被释放的方式是通过移动语义传递。

## 情况详解

### 通过移动语义传递
当你对 `std::unique_ptr` 使用移动语义传递时，如通过 `std::move()`，原始的 `std::unique_ptr` 会将其所有权转移给另一个 `std::unique_ptr`（通常是函数参数）。在所有权转移之后，原始的 `std::unique_ptr` 变为空（即不再指向任何对象），而新的 `std::unique_ptr`（在函数内部）将成为原始对象的唯一持有者。一旦这个新的 `std::unique_ptr` 离开其作用域（例如，函数执行完毕后），它会自动释放它所管理的资源。

### 通过引用传递
当你通过引用传递 `std::unique_ptr` 时，不涉及所有权的转移。这意味着原始的 `std::unique_ptr` 仍然保持对对象的所有权，而函数仅仅是通过引用来操作这个智能指针。因此，当函数执行完毕后，原始的 `std::unique_ptr` 仍然持有对象，并在其自己的作用域结束时负责释放资源。

### 使用原始指针
当使用原始指针参数传递 `std::unique_ptr` 所管理的对象时，这同样不涉及所有权的转移。你只是将对象的地址传递给函数，而原始的 `std::unique_ptr` 保持对对象的完整所有权。这种方法允许函数访问和操作对象，但不负责对象的生命周期管理。

总结：
- 使用**移动语义传递**后，原始的 `std::unique_ptr` 不再持有任何对象，所有权完全转移到函数内的 `std::unique_ptr`。这通常用于你希望函数完全接管对象所有权的场景。
- **通过引用传递**和**使用原始指针**的方法不涉及所有权转移，原始的 `std::unique_ptr` 在函数调用后仍保持对对象的所有权。

这些方法根据你的具体需求（是否需要转移所有权，或者仅需要访问和修改对象）来选择最适合的一种。