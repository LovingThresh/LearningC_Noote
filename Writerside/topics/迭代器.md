# 迭代器

## 迭代器类型
在 C++ 中，迭代器是一种允许程序员按照顺序访问容器（如数组、列表、集合等）中元素的对象。标准模板库（STL）定义了多种类型的迭代器，每种迭代器提供了不同级别的访问和操作容器元素的能力。C++ 标准中定义的六大类迭代器是：

### 1. 输入迭代器（Input Iterators）
输入迭代器支持对数据的读取操作，但只能向前移动（单向移动），并且每个元素只能读取一次。这种迭代器至少支持以下操作：
- `operator*`（解引用，用于访问元素）
- `operator++`（前缀和后缀，用于迭代到下一个元素）
- `operator==` 和 `operator!=`（比较两个迭代器是否相等）

输入迭代器通常用于从数据源读取数据，例如从文件或网络流中读取。

### 2. 输出迭代器（Output Iterators）
输出迭代器支持对数据的写入操作，但也只能向前移动，并且每个元素只能写入一次。支持的操作包括：
- `operator*`（解引用，用于写入元素）
- `operator++`（前缀和后缀，用于迭代到下一个元素）

输出迭代器常用于写入数据到目的地，如填充数组或其他容器。

### 3. 前向迭代器（Forward Iterators）
前向迭代器扩展了输入迭代器的功能，支持多次读取和写入同一个元素。除了支持输入迭代器的所有操作，前向迭代器还保证多次遍历会访问相同的元素序列。前向迭代器特别适合用于那些需要多次遍历数据但不需要元素间随机访问的算法。

### 4. 双向迭代器（Bidirectional Iterators）
双向迭代器支持在容器中前后移动，提供比前向迭代器更多的灵活性。除了前向迭代器的所有操作，双向迭代器还支持：
- `operator--`（前缀和后缀，用于迭代到上一个元素）

双向迭代器适用于如双向链表等数据结构，其中元素需要前后遍历。

### 5. 随机访问迭代器（Random Access Iterators）
随机访问迭代器提供了最强大的功能，支持直接访问任意元素，具有与指针类似的功能。除了支持双向迭代器的所有操作，它还支持：
- `operator[]`（随机访问）
- `operator+=`，`operator-=`（迭代器加/减一个整数）
- `operator+`，`operator-`（迭代器之间的加减运算）
- `operator<`，`operator>`，`operator<=`，`operator>=`（迭代器之间的关系比较）

随机访问迭代器适用于像数组和向量这样的容器，其中可以快速随机访问元素。

### 6. 连续迭代器（Contiguous Iterators）
C++20 引入了连续迭代器，这是一种特殊的随机访问迭代器，它保证底层元素在内存中物理连续存储。这对于与底层 C 数组或其他需要直接内存访问的操作（如某些系统调用或优化的内存操作）的互操作非常有用。

每种类型的迭代器都设计有适合其特定需求的接口和能

力，使得 C++ 的容器和算法既灵活又强大。理解这些迭代器的不同和使用场景对于高效使用 C++ STL 至关重要。

## 迭代器使用
在 C++ 标准模板库（STL）中使用迭代器时，通常你确实不需要显式声明迭代器的具体类型，如输入迭代器、输出迭代器、前向迭代器等。这些类型主要是为了在设计和实现库时对迭代器的功能进行分类和约束，确保算法能够正确地应用于支持相应操作的迭代器上。

### 隐性的迭代器类型

当你从一个容器如 `std::vector`, `std::list` 等获取迭代器时，容器自动提供了适合其结构的迭代器类型：

- **使用**：当你调用 `begin()` 或 `end()` 等方法获取迭代器时，你得到的迭代器类型是由容器的类型隐式确定的。例如，`std::vector` 提供随机访问迭代器，而 `std::list` 提供双向迭代器。
- **无需显式声明**：在日常使用中，你不需要关心获取的是哪种具体的迭代器类型，因为迭代器已经封装了所有必要的操作（如递增、递减、解引用等）。你只需使用迭代器完成遍历、访问或修改元素的任务。

### 迭代器的泛化使用

迭代器的设计允许函数和算法以一种类型无关的方式工作，即它们可以接受任何提供了所需操作的迭代器类型：

- **泛化算法**：STL 算法，如 `std::sort`, `std::find` 等，通常要求传入迭代器区间（`begin` 和 `end`）。这些算法根据传入的迭代器类型的能力执行操作，但调用者不需要指定迭代器的具体分类。
- **模板编程**：在模板编程中，迭代器作为模板参数时，通常不需要指明是哪种类型的迭代器。模板的编写者会通过迭代器支持的操作来隐式地要求迭代器的最小功能。

### 例子

以下是一个使用迭代器的示例，无需关心迭代器的具体类型：

```c++
#include <vector>
#include <algorithm>
#include <iostream>

int main() {
    std::vector<int> vec = {10, 20, 30, 40, 50};

    // std::vector 提供的是随机访问迭代器
    auto it = std::find(vec.begin(), vec.end(), 30);
    if (it != vec.end()) {
        std::cout << "Found: " << *it << "\n";
    }

    // 使用算法，不需知道迭代器的具体类型
    std::sort(vec.begin(), vec.end());
    for (int val : vec) {
        std::cout << val << " ";
    }
    std::cout << "\n";
}
```

### 结论

虽然迭代器的具体类型在库的设计和文档中非常重要，以确保正确使用和实现算法，但在日常使用中，迭代器类型是隐式的，开发者通常不需要直接处理这些类型。这种设计抽象了迭代器的复杂性，使得开发者可以更专注于业务逻辑的实现。

## 推荐用法
在 C++ 中，推荐使用非成员函数 `std::begin()` 和 `std::end()` 而不是容器的成员函数 `container.begin()` 和 `container.end()` 有几个原因，这些原因涉及到代码的泛化、可适用性以及与 C 风格数组的兼容性。

### 1. 泛化和适用性

使用非成员函数 `std::begin()` 和 `std::end()` 可以使你的代码更加泛化，因为这些函数不仅可以用于所有标准容器，还可以用于没有成员 `begin()` 和 `end()` 的普通数组，以及通过自定义特化实现了这些方法的用户定义类型。这意味着同一段代码可以用于多种不同类型的容器，增加了代码的复用性。

#### 示例
```c++
#include <vector>
#include <array>
#include <iostream>

template<typename Container>
void printElements(const Container& c) {
    for (auto it = std::begin(c); it != std::end(c); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> vec = {1, 2, 3};
    int arr[] = {4, 5, 6};
    std::array<int, 3> arr2 = {7, 8, 9};

    printElements(vec);
    printElements(arr);
    printElements(arr2);
}
```

在这个例子中，函数 `printElements` 可以接受任何类型的容器，包括标准库容器和普通数组。

### 2. 与 C 风格数组的兼容性

正如上面示例所示，`std::begin()` 和 `std::end()` 可以与 C 风格数组一起使用，这在 C++ 中仍然很常见。如果你的函数需要能够同时处理标准容器和数组，使用这些非成员函数是非常有用的。

### 3. 自定义类型的适配

如果你有一个自定义容器类型，可能没有实现 `begin()` 和 `end()` 成员函数，但可以通过在命名空间 `std` 中特化 `std::begin` 和 `std::end` 为这些类型提供支持。这样，你可以保持一致的接口，同时使你的自定义类型能够在期望使用 `std::begin()` 和 `std::end()` 的标准算法中工作。

### 4. 标准实践

从 C++11 开始，标准库推荐使用非成员函数形式来处理范围操作，这是现代 C++ 中推荐的实践。这种做法不仅提高了代码的一致性，而且与其他语言特性（如范围基于的 for 循环）协同工作更加自然。

### 结论

总的来说，使用 `std::begin()` 和 `std::end()` 而不是容器的成员函数版本，可以提高代码的通用性和灵活性。这使得编写的代码更加健壮，易于维护和扩展，尤其是在处理多种类型的容器或数据结构时。