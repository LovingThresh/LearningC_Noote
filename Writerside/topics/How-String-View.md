# How String_View

#### 作用
`std::string_view`是C++标准库在C++17中引入的一个轻量级、高效的数据结构，其设计目的是为了提供对原始字符数据的只读访问，
而无需复制或管理这些数据。`std::string_view`的主要作用和优势如下：

1. **零成本引用**：`std::string_view`不存储字符串数据本身，而是持有一个指向现有字符数据的指针和一个表示字符串长度的计数器。
这意味着创建一个`string_view`几乎是瞬时的，不需要额外的内存分配或数据复制，仅需保存对已有字符串数据的引用。
这使得它非常适合在性能敏感的场合中作为函数参数或临时对象，替代传统的`std::string`或`const char*`指针。

2. **兼容多种字符串类型**：`string_view`可以轻松地与`std::string`、`char[]`数组、`const char*`指针（包括字符串字面量）以及其他任何连续的字符序列（如`std::vector<char>`）交互。
它提供了一种统一的方式来处理各种不同来源的字符串数据，增强了代码的通用性和可重用性。

3. **避免不必要的字符串复制**：在许多算法和函数中，字符串数据仅被用来读取，而不做修改。
在这种情况下，使用`string_view`代替`std::string`作为参数可以避免不必要的字符串复制，显著提高性能，尤其是对于大型字符串或在循环中频繁调用的情况。

4. **保留原始数据的生命周期**：`string_view`本身不管理所引用的字符数据的生命周期，它假设这些数据在其存在期间是有效的。
因此，使用`string_view`时，程序员必须确保底层数据在`string_view`使用期间不会被释放或修改。这要求对原始数据的生命周期有清晰的理解和控制，但也因此避免了不必要的内存管理开销。

5. **增强API设计**：`string_view`可以改善API设计的灵活性和效率。接受`string_view`作为参数的函数或方法表明它们不会修改传入的字符串数据，
且不关心数据的具体存储形式（即是否为`std::string`实例）。这简化了接口，鼓励了值语义的使用，并允许用户以最高效的方式传递字符串数据。

6. **支持字符串操作**：虽然`string_view`本身是只读的，但它提供了类似于`std::string`的一些基本操作，如访问、比较、查找子字符串、切片（substring）等。这些功能使得`string_view`在很多情况下可以作为`std::string`的轻量级替代品，尤其是在读取和分析字符串时。

总的来说，`std::string_view`旨在作为一个轻量、高效的字符串引用工具，它通过避免数据复制、兼容多种字符串类型、保持对原始数据的依赖以及提供必要的字符串操作支持，极大地提升了C++代码中处理字符串数据的性能、灵活性和简洁性。在适合其使用场景的情况下，`std::string_view`是现代C++编程实践中优化字符串处理的重要工具。

#### 大小

关于`std::string_view`在64位系统中的大小，我们需要考虑`std::string_view`的内部结构。
`std::string_view`是一个轻量级的类，它通常包含两个成员变量：

1. **指向字符数据的指针**：存储字符串数据的起始地址，类型为`const char*`或`const wchar_t*`等，具体取决于`string_view`的模板参数。
在64位系统中，指针通常占用8个字节。

2. **字符串长度**：表示字符串的有效字符数量，通常是一个无符号整型变量（如`size_t`），在64位系统中，`size_t`的大小通常是与指针相同的8个字节，以保证能表示足够大的字符串长度。

因此，不考虑任何编译器特定的对齐要求，`std::string_view`的大小通常就是这两个成员变量的大小之和：

- 指针：8字节
- 长度（`size_t`）：8字节

**总计：** `std::string_view`在64位系统中通常占用**16字节**。

#### 使用条件
`std::string_view`的主要功能之一是作为一种更高效、更灵活的参数类型，可以在许多情况下替代`const std::string&`作为函数参数。但这并不意味着`string_view`完全替代了`const std::string&`的所有用途。两者各有其适用场景和优势，下面是对`string_view`替代`const std::string&`这一角色的详细说明：

**`string_view`作为`const std::string&`的替代优点**：

1. **避免不必要的字符串复制**：当传递一个`std::string`实例作为`const std::string&`参数时，如果源字符串已经是一个`std::string`对象，那么不需要额外复制。但如果源字符串是字符数组、`const char*`指针或其它非`std::string`类型，编译器可能会隐式创建一个临时`std::string`对象来适配函数参数。而使用`string_view`，无论源字符串是什么类型，都可以直接创建一个`string_view`实例来引用原有数据，无需复制。

2. **降低函数接口的耦合性**：`string_view`不强制调用者提供一个`std::string`实例，它可以接受任何符合其要求（即连续字符序列）的数据源。这使得函数接口更加通用，能够更好地与不同类型的字符串数据源协同工作。

3. **减少内存分配和管理开销**：由于`string_view`不拥有其所引用的数据，因此不需要进行内存分配或管理。这有助于减少潜在的内存分配和释放操作，特别是在处理大量短字符串或在性能敏感的循环中。

4. **较小的传递成本**：`string_view`通常比`std::string`实例小得多（通常只有指针和长度信息），因此在函数调用时传递的成本更低。这对于大型项目或需要优化性能的场景尤为有益。

**何时仍应使用`std::string&`**：

1. **需要修改字符串内容**：如果函数需要修改传入字符串的内容，那么必须使用`std::string`实例作为参数，因为`string_view`是只读的。

2. **确保字符串生命周期**：`string_view`依赖于外部数据的持续有效性。如果函数需要确保字符串数据在整个函数执行期间都有效，或者在函数返回后依然可用，使用`std::string`实例作为参数可以更明确地控制字符串的生命周期。

3. **需要共享所有权或管理资源**：在某些情况下，可能需要函数之间共享对同一字符串数据的所有权或管理责任。这时，使用`std::shared_ptr<std::string>`等智能指针或者直接传递`std::string`实例更为合适，因为它们能提供明确的资源所有权和生命周期管理。

综上所述，`std::string_view`在许多情况下可以作为`const std::string&`的有效替代，特别是在关注性能、降低耦合性和接受多种字符串类型作为输入的场景中。然而，当需要修改字符串、确保数据长期有效或进行资源所有权管理时，仍然需要使用`std::string`实例。正确选择使用哪种类型取决于具体的应用场景和需求。
