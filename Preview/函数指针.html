<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2023-12-11T09:36:15.7203834"><meta name="build-number" content="${buildNumber}">       <title>函数指针 | Code Instance</title><script id="virtual-toc-data" type="application/json">[{"id":"bbcac526_1612","level":0,"title":"函数名与函数指针","anchor":"#bbcac526_1612"},{"id":"bbcac526_1634","level":0,"title":"函数对象","anchor":"#bbcac526_1634"},{"id":"bbcac526_1659","level":0,"title":"函数对象作用过程","anchor":"#bbcac526_1659"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="函数指针 | Code Instance"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Code Instance Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="函数指针.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="函数指针 | Code Instance"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "函数指针.html#webpage", "url": "函数指针.html", "name": "函数指针 | Code Instance", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Code Instance Help" }</script><!-- End Schema.org --></head>      <body data-id="函数指针" data-main-title="函数指针" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="地址与指针.md|地址与指针"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Code Instance  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="函数指针"   id="函数指针.md">函数指针</h1>  <section class="chapter"><h2 id="bbcac526_1612" data-toc="bbcac526_1612"   >函数名与函数指针</h2><p id="bbcac526_1613">在C++中，函数名可以被用作指向函数的指针。在C++中，函数名代表的是函数的内存地址。</p><ul class="list _ul" id="bbcac526_1614"><li class="list__item" id="bbcac526_1615"><p id="bbcac526_1616">当声明一个函数，如 <code class="code" id="bbcac526_1617">void myFunction()</code> ，编译器会分配一个地址给这个函数，可以通过函数名 <code class="code" id="bbcac526_1618">myFunction</code> 来引用这个地址。</p></li><li class="list__item" id="bbcac526_1619"><p id="bbcac526_1620">函数指针是一种特殊类型的指针，专门用于存储函数的地址。它的声明需要匹配函数的签名。</p></li><li class="list__item" id="bbcac526_1621"><p id="bbcac526_1622">例如，如果 <code class="code" id="bbcac526_1623">myFunction</code> 是一个返回 <code class="code" id="bbcac526_1624">void</code> 并且不接受任何参数的函数，那么对应的函数指针可以这样声明：</p><div class="code-block" data-lang="cpp"         >
void (*functionPointer)() = myFunction;
</div><ul class="list _ul" id="bbcac526_1626"><li class="list__item" id="bbcac526_1627"><p>这里<code class="code" id="bbcac526_1628">functionPointer</code> 是一个指针，指向 <code class="code" id="bbcac526_1629">myFunction</code> 函数。你可以通过 <code class="code" id="bbcac526_1630">(*functionPointer)()</code> 或 <code class="code" id="bbcac526_1631">functionPointer()</code> 来调用 <code class="code" id="bbcac526_1632">myFunction</code>。</p></li></ul></li></ul><p id="bbcac526_1633">这个特性在C++中被广泛用于回调机制、事件处理和多态性。通过函数指针，你可以在运行时决定调用哪个函数，增加了代码的灵活性。</p></section><section class="chapter"><h2 id="bbcac526_1634" data-toc="bbcac526_1634"   >函数对象</h2><div class="code-block" data-lang="cpp"         >
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    using namespace std;
    
    template &lt;class T&gt;
    void general( vector&lt;int&gt;::iterator begin, vector&lt;int&gt;::iterator end, T f)
    {
        vector&lt;int&gt;::iterator itr;
        for (itr = begin; itr != end; ++itr) f(*itr);
    }
    
    void add( int &amp;rr) { ++rr; }
    void output( const int &amp;rr) { cout &lt;&lt; rr &lt;&lt; '\t'; }
    
    int main()
    {
        vector&lt;int&gt; v;
        v.push_back(10); v.push_back(3); v.push_back(4);
        general(v.begin(), v.end(), add);
        general(v.begin(), v.end(), output);
        cout &lt;&lt; endl;
    
        return 0;
    }
</div><ul class="list _ul" id="bbcac526_1636"><li class="list__item" id="bbcac526_1637"><p id="bbcac526_1638">在C++中，函数对象（也称为仿函数）是指任何可以通过调用操作符<code class="code" id="bbcac526_1639">()</code>执行的对象。 这通常是通过在类中重载操作符<code class="code" id="bbcac526_1640">()</code>来实现的。函数对象可以像普通函数那样被调用，并且因为它们是对象，所以可以存储状态。</p></li><li class="list__item" id="bbcac526_1641"><p id="bbcac526_1642">在代码示例中， <code class="code" id="bbcac526_1643">general</code>函数接受一个函数对象<code class="code" id="bbcac526_1644">f</code>作为参数，这个函数对象被用于遍历一个<code class="code" id="bbcac526_1645">int</code>向量的所有元素。 <code class="code" id="bbcac526_1646">general</code>函数不关心传递给它的具体操作，它只是对给定范围内的每个元素应用<code class="code" id="bbcac526_1647">f</code>函数对象。</p></li><li class="list__item" id="bbcac526_1648"><p id="bbcac526_1649"><code class="code" id="bbcac526_1650">add</code>和<code class="code" id="bbcac526_1651">output</code>函数都可以被用作<code class="code" id="bbcac526_1652">general</code>的参数，因为它们符合<code class="code" id="bbcac526_1653">general</code>所期望的函数对象签名。 <code class="code" id="bbcac526_1654">add</code>函数对象对每个元素执行自增操作，而<code class="code" id="bbcac526_1655">output</code>函数对象负责输出每个元素。</p></li><li class="list__item" id="bbcac526_1656"><p id="bbcac526_1657">这种将函数作为参数传递的能力使得代码更加灵活和可重用，因为<code class="code" id="bbcac526_1658">general</code>函数不必知道它所应用的操作的具体细节，这些操作可以动态地改变。</p></li></ul></section><section class="chapter"><h2 id="bbcac526_1659" data-toc="bbcac526_1659"   >函数对象作用过程</h2><p id="bbcac526_1660">在代码示例中， <code class="code" id="bbcac526_1661">general</code> 函数模板接受三个参数：两个<code class="code" id="bbcac526_1662">vector&lt;int&gt;::iterator</code>类型的迭代器<code class="code" id="bbcac526_1663">begin</code>和<code class="code" id="bbcac526_1664">end</code> ，以及一个类型为<code class="code" id="bbcac526_1665">T</code>的函数或函数对象<code class="code" id="bbcac526_1666">f</code>。</p><ul class="list _ul" id="bbcac526_1667"><li class="list__item" id="bbcac526_1668"><p>当<code class="code" id="bbcac526_1669">add</code>函数传递给<code class="code" id="bbcac526_1670">general</code>时，模板参数<code class="code" id="bbcac526_1671">T</code>被推断为<code class="code" id="bbcac526_1672">add</code>函数的类型。在C++中，函数可以像指针一样被传递，因此<code class="code" id="bbcac526_1673">add</code>的类型实际上是指向函数的指针，其签名是<code class="code" id="bbcac526_1674">void(int&amp;)</code> ，这意味着它接受一个<code class="code" id="bbcac526_1675">int</code>类型的引用参数并且不返回任何值。</p></li></ul><p id="bbcac526_1676">工作过程如下：</p><ol class="list _decimal" id="bbcac526_1677" type="1"><li class="list__item" id="bbcac526_1678"><p id="bbcac526_1679"><code class="code" id="bbcac526_1680">general</code>函数模板使用类型<code class="code" id="bbcac526_1681">T</code> ，在这个例子中， <code class="code" id="bbcac526_1682">T</code>被推断为<code class="code" id="bbcac526_1683">void(*)(int&amp;)</code>类型，即指向接受<code class="code" id="bbcac526_1684">int</code>引用并返回<code class="code" id="bbcac526_1685">void</code>的函数的指针。</p></li><li class="list__item" id="bbcac526_1686"><p id="bbcac526_1687">在<code class="code" id="bbcac526_1688">general</code>函数内部，通过迭代器遍历<code class="code" id="bbcac526_1689">vector&lt;int&gt;</code>的元素。</p></li><li class="list__item" id="bbcac526_1690"><p id="bbcac526_1691">在遍历过程中，每个元素通过迭代器解引用为<code class="code" id="bbcac526_1692">int&amp;</code>类型，然后将其传递给函数<code class="code" id="bbcac526_1693">f</code>。</p></li><li class="list__item" id="bbcac526_1694"><p id="bbcac526_1695">当<code class="code" id="bbcac526_1696">add</code>作为<code class="code" id="bbcac526_1697">f</code>传递时，它被调用并增加每个元素的值。</p></li><li class="list__item" id="bbcac526_1698"><p id="bbcac526_1699">这样， <code class="code" id="bbcac526_1700">general</code>函数模板就能够以通用的方式应用不同的操作（在这个例子中是<code class="code" id="bbcac526_1701">add</code>和<code class="code" id="bbcac526_1702">output</code> ）到<code class="code" id="bbcac526_1703">vector&lt;int&gt;</code>的所有元素上。</p></li></ol></section><div class="last-modified"> Last modified: 11 十二月 2023</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="指针与动态分配.html">指针与动态分配</a>   <a class="navigation-links__next" href="函数地址.html">函数地址</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>