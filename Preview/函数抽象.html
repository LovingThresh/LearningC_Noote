<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2023-12-11T09:36:15.7203834"><meta name="build-number" content="${buildNumber}">       <title>函数抽象-示例 | Code Instance</title><script id="virtual-toc-data" type="application/json">[{"id":"1c7fb0de_1239","level":0,"title":"准备工作","anchor":"#1c7fb0de_1239"},{"id":"1","level":0,"title":"1. 使用函数指针","anchor":"#1"},{"id":"2","level":0,"title":"2. 使用模板","anchor":"#2"},{"id":"3-lambda","level":0,"title":"3. 使用Lambda表达式","anchor":"#3-lambda"},{"id":"4-functors","level":0,"title":"4. 使用函数对象（Functors）","anchor":"#4-functors"},{"id":"5-std-function","level":0,"title":"5. 使用 std::function","anchor":"#5-std-function"},{"id":"6-std-bind","level":0,"title":"6. 使用 std::bind","anchor":"#6-std-bind"},{"id":"1c7fb0de_1312","level":0,"title":"主函数","anchor":"#1c7fb0de_1312"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="函数抽象-示例 | Code Instance"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Code Instance Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="函数抽象.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="函数抽象-示例 | Code Instance"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "函数抽象.html#webpage", "url": "函数抽象.html", "name": "函数抽象-示例 | Code Instance", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Code Instance Help" }</script><!-- End Schema.org --></head>      <body data-id="函数抽象" data-main-title="函数抽象-示例" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="抽象.md|抽象"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Code Instance  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="函数抽象"   id="函数抽象.md">函数抽象-示例</h1>  <ul class="list _ul" id="1c7fb0de_1236"><li class="list__item" id="1c7fb0de_1237"><p>这个示例将涉及一个简单的排序场景，我们将通过不同的方式提供比较函数。</p></li><li class="list__item" id="1c7fb0de_1238"><p>完整示例：使用不同的函数抽象方法进行排序</p></li></ul><section class="chapter"><h2 id="1c7fb0de_1239" data-toc="1c7fb0de_1239"   >准备工作</h2><p id="1c7fb0de_1240">首先，我们定义两个基本的比较函数，用于升序和降序比较：</p><div class="code-block" data-lang="cpp"         >
// 升序比较函数
bool ascending(int a, int b) {
    return a &lt; b;
}

// 降序比较函数
bool descending(int a, int b) {
    return a &gt; b;
}
</div></section><section class="chapter"><h2 id="1" data-toc="1"   >1. 使用函数指针</h2><ul class="list _ul" id="1c7fb0de_1242"><li class="list__item" id="1c7fb0de_1243"><p><span class="control" id="1c7fb0de_1244">用途</span> ：直接存储和调用函数的地址。</p></li><li class="list__item" id="1c7fb0de_1245"><p><span class="control" id="1c7fb0de_1246">特点</span>： </p><ul class="list _ul" id="1c7fb0de_1247"><li class="list__item" id="1c7fb0de_1248"><p>允许动态选择和调用函数。</p></li><li class="list__item" id="1c7fb0de_1249"><p>常用于回调函数和事件处理。</p></li></ul></li><li class="list__item" id="1c7fb0de_1250"><p><span class="control" id="1c7fb0de_1251">示例</span>： 我们可以定义一个接受函数指针的 <code class="code" id="1c7fb0de_1252">sort</code> 函数：</p></li></ul><div class="code-block" data-lang="cpp"         >
void sortWithPointer(int* array, int size, bool (*compare)(int, int)) {
    // 这里简单地使用冒泡排序作为示例
    for (int i = 0; i &lt; size - 1; ++i) {
        for (int j = 0; j &lt; size - i - 1; ++j) {
            if (compare(array[j], array[j + 1])) {
                std::swap(array[j], array[j + 1]);
            }
        }
    }
}
</div></section><section class="chapter"><h2 id="2" data-toc="2"   >2. 使用模板</h2><ul class="list _ul" id="1c7fb0de_1254"><li class="list__item" id="1c7fb0de_1255"><p><span class="control" id="1c7fb0de_1256">用途</span> ：在编译时确定调用的函数类型。</p></li><li class="list__item" id="1c7fb0de_1257"><p><span class="control" id="1c7fb0de_1258">特点</span>： </p><ul class="list _ul" id="1c7fb0de_1259"><li class="list__item" id="1c7fb0de_1260"><p>提供了编译时的类型检查和更多的灵活性。</p></li><li class="list__item" id="1c7fb0de_1261"><p>可以内联函数调用，提高性能。</p></li></ul></li><li class="list__item" id="1c7fb0de_1262"><p><span class="control" id="1c7fb0de_1263">示例</span>： 使用模板允许我们传递任何可调用对象：</p></li></ul><div class="code-block" data-lang="cpp"         >
template&lt;typename Compare&gt;
void sortWithTemplate(int* array, int size, Compare compare) {
    for (int i = 0; i &lt; size - 1; ++i) {
        for (int j = 0; j &lt; size - i - 1; ++j) {
            if (compare(array[j], array[j + 1])) {
                std::swap(array[j], array[j + 1]);
            }
        }
    }
}
</div></section><section class="chapter"><h2 id="3-lambda" data-toc="3-lambda"   >3. 使用Lambda表达式</h2><ul class="list _ul" id="1c7fb0de_1265"><li class="list__item" id="1c7fb0de_1266"><p><span class="control" id="1c7fb0de_1267">用途</span> ：定义匿名函数。</p></li><li class="list__item" id="1c7fb0de_1268"><p><span class="control" id="1c7fb0de_1269">特点</span>： </p><ul class="list _ul" id="1c7fb0de_1270"><li class="list__item" id="1c7fb0de_1271"><p>灵活且简洁，适用于简单的一次性函数。</p></li><li class="list__item" id="1c7fb0de_1272"><p>可以捕获作用域内的变量。</p></li></ul></li><li class="list__item" id="1c7fb0de_1273"><p><span class="control" id="1c7fb0de_1274">示例</span>： Lambda表达式可以直接在调用点定义：</p></li></ul><div class="code-block" data-lang="cpp"         >
auto lambdaAscend = [](int a, int b) { return a &lt; b; };
auto lambdaDescend = [](int a, int b) { return a &gt; b; };
</div></section><section class="chapter"><h2 id="4-functors" data-toc="4-functors"   >4. 使用函数对象（Functors）</h2><ul class="list _ul" id="1c7fb0de_1276"><li class="list__item" id="1c7fb0de_1277"><p><span class="control" id="1c7fb0de_1278">用途</span> ：通过对象实例调用重载的 <code class="code" id="1c7fb0de_1279">operator()</code>。</p></li><li class="list__item" id="1c7fb0de_1280"><p><span class="control" id="1c7fb0de_1281">特点</span>： </p><ul class="list _ul" id="1c7fb0de_1282"><li class="list__item" id="1c7fb0de_1283"><p>可以携带状态（成员变量）。</p></li><li class="list__item" id="1c7fb0de_1284"><p>性能通常优于传统函数指针。</p></li></ul></li><li class="list__item" id="1c7fb0de_1285"><p><span class="control" id="1c7fb0de_1286">示例</span>： 定义函数对象：</p></li></ul><div class="code-block" data-lang="cpp"         >
struct FunctorAscend {
    bool operator()(int a, int b) const { return a &lt; b; }
};

struct FunctorDescend {
    bool operator()(int a, int b) const { return a &gt; b; }
};
</div></section><section class="chapter"><h2 id="5-std-function" data-toc="5-std-function"   >5. 使用 std::function</h2><ul class="list _ul" id="1c7fb0de_1288"><li class="list__item" id="1c7fb0de_1289"><p><span class="control" id="1c7fb0de_1290">用途</span> ：通用的可调用实体封装。</p></li><li class="list__item" id="1c7fb0de_1291"><p><span class="control" id="1c7fb0de_1292">特点</span>： </p><ul class="list _ul" id="1c7fb0de_1293"><li class="list__item" id="1c7fb0de_1294"><p>可以存储、复制和调用任何可调用实体。</p></li><li class="list__item" id="1c7fb0de_1295"><p>提供了灵活性但可能有额外的性能开销。</p></li></ul></li><li class="list__item" id="1c7fb0de_1296"><p><span class="control" id="1c7fb0de_1297">示例</span>： 将函数封装为 <code class="code" id="1c7fb0de_1298">std::function</code>：</p></li></ul><div class="code-block" data-lang="cpp"         >
std::function&lt;bool(int, int)&gt; funcAscend = ascending;
std::function&lt;bool(int, int)&gt; funcDescend = descending;
</div></section><section class="chapter"><h2 id="6-std-bind" data-toc="6-std-bind"   >6. 使用 std::bind</h2><ul class="list _ul" id="1c7fb0de_1300"><li class="list__item" id="1c7fb0de_1301"><p><span class="control" id="1c7fb0de_1302">用途</span> ：创建绑定特定参数的可调用实体。</p></li><li class="list__item" id="1c7fb0de_1303"><p><span class="control" id="1c7fb0de_1304">特点</span>： </p><ul class="list _ul" id="1c7fb0de_1305"><li class="list__item" id="1c7fb0de_1306"><p>适用于需要预先指定一部分参数的场景。</p></li><li class="list__item" id="1c7fb0de_1307"><p>语法比Lambda复杂，但在某些情况下非常有用。</p></li></ul></li><li class="list__item" id="1c7fb0de_1308"><p><span class="control" id="1c7fb0de_1309">示例</span>： 虽然在这个特定示例中 <code class="code" id="1c7fb0de_1310">std::bind</code> 不是必需的，但它可以用于更复杂的场景，比如预绑定某些参数：</p></li></ul><div class="code-block" data-lang="cpp"         >
auto boundAscend = std::bind(ascending, std::placeholders::_1, std::placeholders::_2);
</div></section><section class="chapter"><h2 id="1c7fb0de_1312" data-toc="1c7fb0de_1312"   >主函数</h2><p id="1c7fb0de_1313">在主函数中，我们可以创建一个数组并使用不同的方法对其进行排序：</p><div class="code-block" data-lang="cpp"         >
int main() {
    int array[10] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};

    // 使用函数指针
    sortWithPointer(array, 10, ascending);

    // 使用模板
    sortWithTemplate(array, 10, FunctorAscend());

    // 使用Lambda表达式
    sortWithTemplate(array, 10, lambdaAscend);

    // 使用std::function
    sortWithTemplate(array, 10, funcAscend);

    // 使用std::bind（如果适用）
    // sortWithTemplate(array, 10, boundAscend);

    return 0;
}
</div></section><div class="last-modified"> Last modified: 11 十二月 2023</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="抽象.html">抽象</a>   <a class="navigation-links__next" href="vector.html">Vector</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>