<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2023-12-11T09:36:15.7093852"><meta name="build-number" content="${buildNumber}">       <title>类型转换 | Code Instance</title><script id="virtual-toc-data" type="application/json">[]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="类型转换 | Code Instance"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Code Instance Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="类型转换.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="类型转换 | Code Instance"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "类型转换.html#webpage", "url": "类型转换.html", "name": "类型转换 | Code Instance", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Code Instance Help" }</script><!-- End Schema.org --></head>      <body data-id="类型转换" data-main-title="类型转换" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs=""  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Code Instance  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="类型转换"   id="类型转换.md">类型转换</h1>  <p id="84255e62_1170">C++中的类型转换运算符用于将一种数据类型转换为另一种类型。在C++中，有四种主要的类型转换运算符：</p><ol class="list _decimal" id="84255e62_1171" type="1"><li class="list__item" id="84255e62_1172"><p id="84255e62_1173"><span class="control" id="84255e62_1174">static_cast</span>: 用于非多态类型的转换。它在编译时执行，没有运行时类型检查来保证转换的安全。它主要用于转换数值数据类型（如 <code class="code" id="84255e62_1175">int</code> 到 <code class="code" id="84255e62_1176">float</code> ）、将 <code class="code" id="84255e62_1177">void*</code> 指针转换成目标类型的指针等。</p><p id="84255e62_1178">示例：</p><div class="code-block" data-lang="cpp"         >
double d = 10.5;
int i = static_cast&lt;int&gt;(d);  // 将 double 转换为 int
</div></li><li class="list__item" id="84255e62_1180"><p id="84255e62_1181"><span class="control" id="84255e62_1182">dynamic_cast</span>: 专门用于处理多态。用于类的向上转换（例如将派生类指针或引用转换为基类指针或引用）和向下转换（将基类指针或引用转换为派生类指针或引用）。向下转换时，如果转换无效，则会返回空指针。</p><p id="84255e62_1183">示例：</p><div class="code-block" data-lang="cpp"         >
class Base {};
class Derived : public Base {};
Base *b = new Derived;
Derived *d = dynamic_cast&lt;Derived*&gt;(b);  // 向下转换
</div></li><li class="list__item" id="84255e62_1185"><p id="84255e62_1186"><span class="control" id="84255e62_1187">const_cast</span>: 用于去除或添加<code class="code" id="84255e62_1188">const</code>属性。它可以将<code class="code" id="84255e62_1189">const</code>对象转换为非<code class="code" id="84255e62_1190">const</code>对象，反之亦然。</p><p id="84255e62_1191">示例：</p><div class="code-block" data-lang="cpp"         >
const int x = 10;
int* y = const_cast&lt;int*&gt;(&amp;x);  // 去除 const 属性
</div><ul class="list _ul" id="84255e62_1193"><li class="list__item" id="84255e62_1194"><p>在C++中，一旦一个对象被声明为<code class="code" id="84255e62_1195">const</code> ，这通常意味着该对象不应该被修改（但是你没有办法让所有人都写出正确的代码，而类型转换符为我们提供个亡羊补牢的机会，不至于束手无策）。 <code class="code" id="84255e62_1196">const</code>关键字的使用主要有两个目的：</p></li></ul><ol class="list _decimal" id="84255e62_1197" type="1"><li class="list__item" id="84255e62_1198"><p id="84255e62_1199"><span class="control" id="84255e62_1200">提供编程上的保证</span> ：当你将一个对象标记为<code class="code" id="84255e62_1201">const</code> ，你告诉编译器和其他程序员这个对象不应该被修改。这是一种安全和文档化的做法，可以防止编程错误。</p></li><li class="list__item" id="84255e62_1202"><p id="84255e62_1203"><span class="control" id="84255e62_1204">优化</span> ：知道某些数据不会改变，编译器可以进行更有效的代码优化。在大多数情况下，尝试修改一个<code class="code" id="84255e62_1205">const</code>对象是不合适的。然而，存在一些特殊情况，你可能会考虑到使用<code class="code" id="84255e62_1206">const_cast</code>来移除<code class="code" id="84255e62_1207">const</code>限定符：</p><ol class="list _decimal" id="84255e62_1208" type="1"><li class="list__item" id="84255e62_1209"><p id="84255e62_1210"><span class="control" id="84255e62_1211">与C语言代码的接口</span> ：有时你可能需要使用旧的C代码，这些代码没有使用<code class="code" id="84255e62_1212">const</code>关键字。例如，你有一个C函数接受非<code class="code" id="84255e62_1213">const</code>指针，但你的数据是<code class="code" id="84255e62_1214">const</code>的。在这种情况下，你可能需要使用<code class="code" id="84255e62_1215">const_cast</code>来适应这个接口。</p></li><li class="list__item" id="84255e62_1216"><p id="84255e62_1217"><span class="control" id="84255e62_1218">处理第三方库</span> ：当使用第三方库时，你可能遇到只接受非<code class="code" id="84255e62_1219">const</code>参数的函数，即使它们实际上不修改参数。在这种情况下， <code class="code" id="84255e62_1220">const_cast</code>可以被用来适配这些接口。</p></li><li class="list__item" id="84255e62_1221"><p id="84255e62_1222"><span class="control" id="84255e62_1223">类内部的状态修改</span> ：有时，你可能想在一个<code class="code" id="84255e62_1224">const</code>成员函数内修改类的某些成员变量。这些变量通常用于缓存或类似的优化目的，而不影响类的外部状态（逻辑上的<code class="code" id="84255e62_1225">const</code> ）。在这种情况下，可以使用<code class="code" id="84255e62_1226">mutable</code>关键字或<code class="code" id="84255e62_1227">const_cast</code>。</p></li></ol></li></ol></li><li class="list__item" id="84255e62_1228"><p id="84255e62_1229"><span class="control" id="84255e62_1230">reinterpret_cast</span>: 提供了低级别的重新解释转换。它可以用于任意指针类型之间的转换，甚至也可以用于指针和足够大的整数类型之间的转换。由于这种转换的危险性较高，应当谨慎使用。</p><p id="84255e62_1231">示例：</p><div class="code-block" data-lang="cpp"         >
int* p = new int(65);
char* ch = reinterpret_cast&lt;char*&gt;(p);  // 将 int* 转换为 char*
</div></li></ol><p id="84255e62_1233">每种转换运算符都有其特定用途和潜在风险，因此在使用时应当明确目的并确保安全性。尤其是<code class="code" id="84255e62_1234">reinterpret_cast</code>和<code class="code" id="84255e62_1235">const_cast</code> ，由于它们可以打破类型系统的规则，因此使用时需要特别小心。</p><div class="last-modified"> Last modified: 11 十二月 2023</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">   <a class="navigation-links__next" href="属性.html">属性</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>